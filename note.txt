Classes du projet
1 - Application - Orchestration principale
2 - Object      - Contient l'objet : les points, normales, faces, textures
3 - Renderer    - Gere ce qui touche au GPU
9 - Mat4		- Permet de creer et manipuler des matrices 4 * 4

	RENDERER :
C'est le responsable de tout ce qui touche a OpenGl
	Charge et compile les shaders (vertex, fragment et eventuellement geometry)
	Configure les etats OpenGL globaux (profondeur, culling, blending, clear color...)
	Gere les ressources liees au rendu (buffers generaux ou textures propres au rendu)
	Fournit la fonction render() qui prend un modele, une camera et un materiau pour dessiner l'objet a l'ecran
	
Renderer ne stocke pas les objets eux-memes mais s'occupe de tout ce qui est preparation GPU pour dessiner et de l'execution du draw call


1 - Traiter l'objet : recuperer le maillage de point, les normales, les coordonnees des textures etc;
2 - Recuperer les paths des textures depuis l'objet;
3 - Recreer la triangulation si necessaire, si une face a plus de 3 vertices
4 - Creer les textures OpenGl depuis le renderer;
5 - Initialiser les shaders depuis le renderer
6 - Monter le Mesh : creer le VAO pour le Mesh; le VBO pour les positions, normales et UV;
	creer un EBO pour glDrawElement; Lier les attributs au shader

	On preferera utiliser 3 vbo separes pour les positions, les normales et les UV plutot que d'utiliser
	un seul vbo avec une struct Vertex de 9 elements pour laquelle il faudrait calculer la position de
	depart de chaque triplet.
7 - Creer les matrices view et projection pour voir et avoir de la perspective


vertex.glsl :
	
buildVertex : 
	Si 2 faces partagent la meme position mais ont des UV et normales differents, on fait 2 Vertex differents
	Les triangles ne sont pas decales : chaque triangle utilise exactement les bonnes normales/UV/position
	Si 2 faces utilisent les memes triplets (v, vt, vn), on reutilise le Vertex au lieu d'en creer un nouveau


